<!DOCTYPE html>
<html lang="en" class="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KÄraka Frame Graph | POC Demo</title>
    <meta name="description"
        content="Event-centric semantic extraction and question answering using KÄraka Frame Graph">

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Force Graph library (better interaction/zoom/pan) -->
    <script src="https://unpkg.com/force-graph"></script>
    <!-- D3.js (still useful for other things or legacy) -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        /* ... existing styles ... */
        /* Updated Graph Controls */
        .graph-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 10;
        }

        .control-btn {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--color-muted);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            color: var(--color-foreground);
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: var(--color-border);
            color: white;
        }

        /* Force graph container needs relative positioning for overlay */
        #graph-container {
            position: relative;
            background: var(--color-card);
            /* Subtle grid pattern */
            background-image: radial-gradient(var(--color-border) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        :root {
            /* Dark Mode Base */
            --color-background: #111111;
            --color-foreground: #eaeaea;
            --color-card: #181818;
            --color-border: #333333;
            --color-muted: #222222;
            --color-muted-foreground: #888888;

            /* Brand */
            --color-brand: #df728b;
            --color-brand-hover: #e8899d;
            --color-accent-amber: #F59E0B;
            --color-destructive: #ef4444;
            --color-success: #22c55e;

            /* Spacing */
            --radius-sm: 0.375rem;
            --radius-md: 0.5rem;
            --radius-lg: 1.5rem;
            --radius-full: 9999px;

            /* Typography */
            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;

            --glass-bg: rgba(24, 24, 24, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        /* Inspector Panel */
        .node-inspector {
            position: absolute;
            top: 1rem;
            left: 1rem;
            width: 280px;
            max-height: calc(100% - 2rem);
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: var(--radius-lg);
            padding: 1rem;
            transform: translateX(-110%);
            transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 20;
            overflow-y: auto;
            box-shadow: 0 10px 40px -10px rgba(0, 0, 0, 0.5);
        }

        .node-inspector.visible {
            transform: translateX(0);
        }

        .inspector-header {
            border-bottom: 1px solid var(--color-border);
            padding-bottom: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .inspector-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--color-foreground);
            margin-bottom: 0.25rem;
        }

        .inspector-subtitle {
            font-size: 0.75rem;
            color: var(--color-muted-foreground);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .inspector-content {
            font-size: 0.8125rem;
            color: var(--color-muted-foreground);
        }

        .prop-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .prop-key {
            color: var(--color-muted-foreground);
        }

        .prop-val {
            color: var(--color-foreground);
            text-align: right;
            max-width: 60%;
            word-break: break-word;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    RESET & BASE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--color-background);
            color: var(--color-foreground);
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Noise texture overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            z-index: 9999;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    LAYOUT
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .app-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            /* Equal split as requested */
            grid-template-rows: auto 1fr auto;
            gap: 1.5rem;
            height: 100vh;
            max-height: 100vh;
            padding: 1.5rem;
            max-width: 100%;
            margin: 0;
            overflow: hidden;
            /* Prevent body scroll */
        }

        header {
            grid-column: 1 / -1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--color-border);
            flex-shrink: 0;
        }

        /* ... logo / header styles ... */
        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            color: var(--color-brand);
        }

        .logo h1 {
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }

        .logo span {
            color: var(--color-muted-foreground);
            font-size: 0.75rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--color-muted);
            border-radius: var(--radius-full);
            font-size: 0.875rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--color-destructive);
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--color-success);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Auto-Pilot Toggle */
        .autopilot-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0.75rem;
            background: var(--color-muted);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-full);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
        }

        .autopilot-toggle:hover {
            border-color: var(--color-brand);
        }

        .autopilot-toggle.active {
            background: rgba(223, 114, 139, 0.15);
            border-color: var(--color-brand);
        }

        .autopilot-toggle .toggle-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--color-muted-foreground);
            transition: background 0.2s;
        }

        .autopilot-toggle.active .toggle-indicator {
            background: var(--color-brand);
            box-shadow: 0 0 8px var(--color-brand);
        }

        /* Feature Hint Badge */
        .feature-hint {
            font-size: 0.65rem;
            color: var(--color-brand);
            background: rgba(223, 114, 139, 0.1);
            padding: 0.2rem 0.5rem;
            border-radius: var(--radius-full);
            margin-left: 0.5rem;
            animation: hintPulse 2s ease-in-out 3;
        }

        @keyframes hintPulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Collapsible Panel */
        .panel.collapsible .panel-header {
            cursor: pointer;
            transition: background 0.2s;
        }

        .panel.collapsible .panel-header:hover {
            background: var(--color-border);
        }

        .panel.collapsible .panel-header::after {
            content: 'â–¼';
            font-size: 0.6rem;
            margin-left: 0.75rem;
            opacity: 0.5;
            transition: transform 0.2s, opacity 0.2s;
        }

        .panel.collapsible .panel-header:hover::after {
            opacity: 1;
        }

        .panel.collapsible.collapsed .panel-header::after {
            transform: rotate(-90deg);
        }

        .panel.collapsible.collapsed .panel-content {
            display: none;
        }

        .panel.collapsible.collapsed {
            flex-shrink: 0 !important;
        }


        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    PANELS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .panel {
            background: var(--color-card);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            /* Prevent squashing */
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            border-bottom: 1px solid var(--color-border);
            background: var(--color-muted);
            flex-shrink: 0;
        }

        .panel-title {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--color-muted-foreground);
        }

        .panel-content {
            flex: 1;
            padding: 1.25rem;
            overflow-y: auto;
        }

        /* Left columns - scrollable area */
        .left-column {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            overflow-y: auto;
            /* Independent scroll */
            padding-right: 0.5rem;
            /* Space for scrollbar */
            height: 100%;
            min-width: 0;
            /* Prevent flex blowout */
        }

        /* Custom Scrollbar for left column */
        .left-column::-webkit-scrollbar {
            width: 6px;
        }

        .left-column::-webkit-scrollbar-track {
            background: transparent;
        }

        .left-column::-webkit-scrollbar-thumb {
            background: var(--color-border);
            border-radius: 4px;
        }

        .left-column::-webkit-scrollbar-thumb:hover {
            background: var(--color-muted-foreground);
        }

        /* Right panel (graph) - fixed full height */
        .right-column {
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    INPUT PANEL
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .input-panel .panel-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        textarea {
            width: 100%;
            min-height: 120px;
            padding: 1rem;
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            color: var(--color-foreground);
            font-family: var(--font-sans);
            font-size: 0.9375rem;
            resize: vertical;
            transition: border-color 0.2s ease-out;
        }

        textarea:focus {
            outline: none;
            border-color: var(--color-brand);
        }

        textarea::placeholder {
            color: var(--color-muted-foreground);
        }

        .button-row {
            display: flex;
            gap: 0.75rem;
        }

        button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius-full);
            font-family: var(--font-sans);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease-out;
            border: none;
        }

        .btn-primary {
            background: var(--color-brand);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--color-brand-hover);
            transform: scale(0.98);
        }

        .btn-secondary {
            background: var(--color-muted);
            color: var(--color-foreground);
            border: 1px solid var(--color-border);
        }

        .btn-secondary:hover:not(:disabled) {
            background: var(--color-border);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    PROGRESS BAR
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .progress-container {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
        }

        .progress-container.visible {
            display: flex;
        }

        .progress-bar {
            height: 4px;
            background: var(--color-muted);
            border-radius: var(--radius-full);
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--color-brand);
            border-radius: var(--radius-full);
            transition: width 0.3s ease-out;
            width: 0%;
        }

        .progress-text {
            font-size: 0.8125rem;
            color: var(--color-muted-foreground);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Q&A PANEL
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .qa-panel .panel-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .question-input-row {
            display: flex;
            gap: 0.75rem;
        }

        input[type="text"] {
            flex: 1;
            padding: 0.75rem 1rem;
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-full);
            color: var(--color-foreground);
            font-family: var(--font-sans);
            font-size: 0.9375rem;
            transition: border-color 0.2s ease-out;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--color-brand);
        }

        .answer-box {
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: 1rem;
            min-height: 80px;
        }

        .answer-box.empty {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-muted-foreground);
            font-style: italic;
        }

        .answer-text {
            font-size: 0.9375rem;
            line-height: 1.6;
        }

        .sources-label {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--color-border);
            font-size: 0.75rem;
            color: var(--color-muted-foreground);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .source-tag {
            display: inline-block;
            margin-top: 0.375rem;
            margin-right: 0.375rem;
            padding: 0.25rem 0.5rem;
            background: var(--color-brand);
            color: white;
            border-radius: var(--radius-sm);
            font-size: 0.75rem;
            font-weight: 500;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    FRAMES LIST
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .frames-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .frame-card {
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            padding: 1rem;
            transition: border-color 0.2s ease-out;
        }

        .frame-card:hover {
            border-color: var(--color-brand);
        }

        .frame-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .frame-id {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--color-brand);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .frame-kriya {
            font-size: 1rem;
            font-weight: 600;
            padding: 0.25rem 0.75rem;
            background: var(--color-muted);
            border-radius: var(--radius-full);
        }

        .frame-roles {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .role-tag {
            display: inline-flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.25rem 0.625rem;
            background: var(--color-muted);
            border-radius: var(--radius-sm);
            font-size: 0.8125rem;
        }

        .role-name {
            color: var(--color-muted-foreground);
        }

        .role-value {
            color: var(--color-foreground);
            font-weight: 500;
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 3rem;
            color: var(--color-muted-foreground);
            text-align: center;
        }

        .empty-state-icon {
            width: 48px;
            height: 48px;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    GRAPH VISUALIZATION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .graph-panel {
            flex: 1;
        }

        .graph-panel .panel-content {
            padding: 0;
            position: relative;
        }

        #graph-container {
            width: 100%;
            height: 100%;
            min-height: 500px;
        }

        .graph-node {
            cursor: pointer;
        }

        .graph-node.entity circle {
            fill: var(--color-muted);
            stroke: var(--color-border);
            stroke-width: 2px;
        }

        .graph-node.event circle {
            fill: var(--color-brand);
            stroke: var(--color-brand-hover);
            stroke-width: 2px;
        }

        .graph-node text {
            fill: var(--color-foreground);
            font-size: 11px;
            font-weight: 500;
            pointer-events: none;
        }

        .graph-link {
            stroke: var(--color-border);
            stroke-width: 1.5px;
            fill: none;
        }

        .graph-link-label {
            fill: var(--color-muted-foreground);
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }

        .graph-legend {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            display: flex;
            gap: 1rem;
            font-size: 0.75rem;
            color: var(--color-muted-foreground);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.entity {
            background: var(--color-muted);
            border: 2px solid var(--color-border);
        }

        .legend-dot.event {
            background: var(--color-brand);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    FOOTER
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        footer {
            grid-column: 1 / -1;
            display: flex;
            justify-content: center;
            padding-top: 1rem;
            border-top: 1px solid var(--color-border);
            font-size: 0.8125rem;
            color: var(--color-muted-foreground);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    RESPONSIVE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (max-width: 1024px) {
            .app-container {
                grid-template-columns: 1fr;
            }

            .right-column {
                min-height: 400px;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Header -->
        <header>
            <div class="logo">
                <svg class="logo-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <circle cx="12" cy="12" r="10" />
                    <path d="M12 6v12M6 12h12" />
                    <circle cx="12" cy="12" r="3" fill="currentColor" />
                </svg>
                <div>
                    <h1>KÄraka Frame Graph</h1>
                    <span>POC Demo v0.1</span>
                </div>
            </div>

            <!-- Auto-Pilot Toggle -->
            <div class="autopilot-toggle active" id="autopilotToggle" onclick="toggleStoryMode()"
                title="Auto-focus graph when scrolling through frames">
                <span class="toggle-indicator"></span>
                <span id="autopilotLabel">Auto-Pilot</span>
            </div>

            <div class="status-badge">
                <div class="status-dot" id="statusDot"></div>
                <span id="statusText">Disconnected</span>
            </div>
        </header>

        <!-- Left Column -->
        <div class="left-column">
            <!-- Input Panel -->
            <div class="panel input-panel collapsible" id="inputPanel">
                <div class="panel-header" onclick="togglePanel('inputPanel')">
                    <span class="panel-title">ğŸ“ Input Text</span>
                    <button class="btn-secondary" id="clearBtn" onclick="event.stopPropagation()"
                        style="padding: 0.375rem 0.75rem; font-size: 0.75rem;">Clear All</button>
                </div>
                <div class="panel-content">
                    <textarea id="inputText"
                        placeholder="Enter your text here...&#10;&#10;Example: The European Research Council funded the study in 2022. Dr. Smith conducted the experiments in Berlin using advanced microscopy."></textarea>
                    <div class="button-row">
                        <button class="btn-secondary" id="loadDemoBtn" style="margin-right: 0.5rem;"
                            title="Load pre-extracted demo frames (no API calls)">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <path d="M12 2L12 14M12 14L7 9M12 14L17 9" />
                                <path d="M2 17L2 20C2 21.1 2.9 22 4 22L20 22C21.1 22 22 21.1 22 20L22 17" />
                            </svg>
                            Demo
                        </button>
                        <button class="btn-secondary" id="loadStressBtn"
                            title="Load complex causal chains for reasoning stress test">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
                            </svg>
                            Stress Test
                        </button>
                        <button class="btn-primary" id="processBtn">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="2">
                                <polygon points="5 3 19 12 5 21 5 3" />
                            </svg>
                            Process Text
                        </button>
                    </div>
                    <div class="progress-container" id="progressContainer">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progressFill"></div>
                        </div>
                        <div class="progress-text" id="progressText">Processing...</div>
                    </div>
                </div>
            </div>

            <!-- Q&A Panel -->
            <div class="panel qa-panel collapsible" id="qaPanel">
                <div class="panel-header" onclick="togglePanel('qaPanel')">
                    <span class="panel-title">â“ Ask Questions</span>
                </div>
                <div class="panel-content">
                    <div class="question-input-row">
                        <input type="text" id="questionInput" placeholder="Who funded the study?" />
                        <button class="btn-primary" id="askBtn">Ask</button>
                    </div>
                    <div class="answer-box empty" id="answerBox">
                        Ask a question to get started
                    </div>
                </div>
            </div>

            <!-- Frames Panel -->
            <div class="panel frames-panel" style="flex: 1; min-height: 280px;">
                <div class="panel-header">
                    <span class="panel-title">ğŸ“¦ Extracted Frames</span>
                    <span class="feature-hint" title="Hover roles to highlight graph nodes, scroll to auto-navigate">âœ¨
                        Interactive</span>
                    <span id="frameCount"
                        style="font-size: 0.75rem; color: var(--color-muted-foreground); margin-left: auto;">0
                        frames</span>
                </div>
                <div class="panel-content">
                    <div class="frames-list" id="framesList">
                        <div class="empty-state">
                            <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="1.5">
                                <rect x="3" y="3" width="18" height="18" rx="2" />
                                <path d="M3 9h18M9 21V9" />
                            </svg>
                            <p>No frames extracted yet.<br>Process some text to see frames here.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Graph -->
        <div class="right-column panel graph-panel">
            <div class="panel-header">
                <span class="panel-title">ğŸ”— Frame Graph</span>
            </div>
            <div class="panel-content">
                <div id="graph-container"></div>
                <div class="graph-legend">
                    <div class="legend-item">
                        <div class="legend-dot entity"></div>
                        <span>Entity</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-dot event"></div>
                        <span>Event</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer>
            KÄraka Frame Graph POC â€¢ Event-centric Semantic Extraction
        </footer>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let ws = null;
        let frames = [];
        let graphData = { nodes: [], edges: [] };
        let isStoryMode = true; // Auto-Pilot mode
        let currentGraphInstance = null; // Reference for Neural Link

        // DOM Elements
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const inputText = document.getElementById('inputText');
        const processBtn = document.getElementById('processBtn');
        const loadDemoBtn = document.getElementById('loadDemoBtn');
        const loadStressBtn = document.getElementById('loadStressBtn');
        const clearBtn = document.getElementById('clearBtn');
        const progressContainer = document.getElementById('progressContainer');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const questionInput = document.getElementById('questionInput');
        const askBtn = document.getElementById('askBtn');
        const answerBox = document.getElementById('answerBox');
        const framesList = document.getElementById('framesList');
        const frameCount = document.getElementById('frameCount');

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COLLAPSIBLE PANELS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        window.togglePanel = function (panelId) {
            const panel = document.getElementById(panelId);
            if (panel) {
                panel.classList.toggle('collapsed');
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // WEBSOCKET CONNECTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
                processBtn.disabled = false;
                askBtn.disabled = false;
            };

            ws.onclose = () => {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
                processBtn.disabled = true;
                askBtn.disabled = true;

                // Reconnect after 2 seconds
                setTimeout(connect, 2000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                handleMessage(msg);
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MESSAGE HANDLER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function handleMessage(msg) {
            switch (msg.type) {
                case 'status':
                    progressText.textContent = msg.message;
                    if (msg.progress !== undefined) {
                        progressFill.style.width = `${msg.progress * 100}%`;
                    }
                    break;

                case 'frame':
                    addFrame(msg.data);
                    break;

                case 'graph':
                    graphData = msg.data;
                    renderGraph();
                    break;

                case 'complete':
                    progressContainer.classList.remove('visible');
                    processBtn.disabled = false;
                    break;

                case 'answer':
                    showAnswer(msg);
                    break;

                case 'error':
                    console.error('Server error:', msg.message);
                    progressText.textContent = `Error: ${msg.message}`;
                    break;

                case 'cleared':
                    frames = [];
                    graphData = { nodes: [], edges: [] };
                    renderFramesList();
                    renderGraph();
                    break;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ACTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function processText() {
            const text = inputText.value.trim();
            if (!text) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                processBtn.disabled = true;
                progressContainer.classList.add('visible');
                progressFill.style.width = '0%';
                frames = [];

                ws.send(JSON.stringify({
                    type: 'process_text',
                    text: text
                }));
            }
        }

        function askQuestion() {
            const question = questionInput.value.trim();
            if (!question) return;

            if (ws && ws.readyState === WebSocket.OPEN) {
                askBtn.disabled = true;
                answerBox.innerHTML = '<span style="color: var(--color-muted-foreground)">Thinking...</span>';
                answerBox.classList.remove('empty');

                ws.send(JSON.stringify({
                    type: 'ask_question',
                    question: question
                }));
            }
        }

        function clearAll() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'clear' }));
            }
            inputText.value = '';
            questionInput.value = '';
            answerBox.innerHTML = 'Ask a question to get started';
            answerBox.classList.add('empty');
        }

        function loadDemo() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                frames = [];
                progressContainer.classList.add('visible');
                progressText.textContent = 'Loading demo frames...';
                progressFill.style.width = '50%';

                ws.send(JSON.stringify({ type: 'load_demo' }));

                // Update textarea with demo text
                inputText.value = `The European Research Council funded a large clinical study in 2022.
The study was conducted in Copenhagen using advanced imaging tools.
Dr. Chen led the research on neuroplasticity.
The team published the results in Nature in 2023.`;
            }
        }

        function loadStressTest() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                frames = [];
                progressContainer.classList.add('visible');
                progressText.textContent = 'Loading stress test frames...';
                progressFill.style.width = '50%';

                ws.send(JSON.stringify({ type: 'load_stress_test' }));

                // Update textarea with stress test text
                inputText.value = `In 2019, Professor Sharma discovered a novel protein marker in Mumbai.
This discovery led to a collaboration between IIT Delhi and Stanford University.
Dr. Williams from Stanford analyzed the protein using CRISPR technology.
The analysis revealed that the protein could inhibit cancer cell growth.
In 2021, the team received $5 million funding from the NIH.
The funding enabled them to conduct clinical trials in three countries.
By 2023, the drug had reduced tumor size by 60% in treated patients.
Professor Sharma attributed the success to the collaborative approach.
The FDA approved the drug for Phase 3 trials in December 2023.
Dr. Williams received the Breakthrough Prize for her work on this project.`;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function addFrame(frameData) {
            frames.push(frameData);
            renderFramesList();
        }

        function renderFramesList() {
            frameCount.textContent = `${frames.length} frame${frames.length !== 1 ? 's' : ''}`;

            if (frames.length === 0) {
                framesList.innerHTML = `
                    <div class="empty-state">
                        <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <rect x="3" y="3" width="18" height="18" rx="2"/>
                            <path d="M3 9h18M9 21V9"/>
                        </svg>
                        <p>No frames extracted yet.<br>Process some text to see frames here.</p>
                    </div>
                `;
                return;
            }

            framesList.innerHTML = frames.map((frame, idx) => `
                <div class="frame-card" data-frame-idx="${idx}" data-kriya="${frame.kriya}">
                    <div class="frame-header">
                        <span class="frame-id">${frame.frame_id}</span>
                        <span class="frame-kriya">${frame.kriya}</span>
                    </div>
                    <div class="frame-roles">
                        ${Object.entries(frame.karakas || {}).map(([role, value]) => `
                            <div class="role-tag" 
                                 onmouseenter="highlightNodeByLabel('${value.replace(/'/g, "\\'")}')"
                                 onmouseleave="clearNeuralLink()"
                                 style="cursor: pointer;">
                                <span class="role-name">${role}:</span>
                                <span class="role-value" style="border-bottom: 1px dotted var(--color-brand);">${value}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `).join('');

            // Setup Auto-Pilot observer for scroll-based focus
            setupAutoPilotObserver();
        }

        function showAnswer(msg) {
            askBtn.disabled = false;

            let html = `<div class="answer-text">${msg.answer}</div>`;

            if (msg.sources && msg.sources.length > 0) {
                html += '<div class="sources-label">Sources</div>';
                msg.sources.forEach(src => {
                    html += `<span class="source-tag">${src.frame_id}: ${src.kriya}</span>`;
                });
            }

            answerBox.innerHTML = html;
            answerBox.classList.remove('empty');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GRAPH VISUALIZATION (D3.js)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let simulation = null;

        let graphInstance = null;

        function renderGraph() {
            const container = document.getElementById('graph-container');

            // Clear previous if empty
            if (!graphData.nodes || graphData.nodes.length === 0) {
                container.innerHTML = `
                    <div class="empty-state" style="height: 100%;">
                        <svg class="empty-state-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                        <p>Graph will appear here<br>after processing text.</p>
                    </div>
                `;
                graphInstance = null;
                return;
            }

            // If graph already exists, just update data
            const formattedData = {
                nodes: graphData.nodes,
                links: graphData.edges
            };

            if (graphInstance) {
                graphInstance.graphData(formattedData);
                return;
            }

            // Clean container for fresh init
            container.innerHTML = '';

            // Add Inspector Panel
            const inspector = document.createElement('div');
            inspector.className = 'node-inspector';
            inspector.id = 'nodeInspector';
            inspector.innerHTML = `
                <div class="inspector-header">
                    <div class="inspector-title" id="inspectorTitle">Node Name</div>
                    <div class="inspector-subtitle" id="inspectorType">Node Type</div>
                </div>
                <div class="inspector-content" id="inspectorContent"></div>
            `;
            container.appendChild(inspector);

            // Add Controls
            const controls = document.createElement('div');
            controls.className = 'graph-controls';
            controls.innerHTML = `
                <button class="control-btn" onclick="zoomGraph(1.5)" title="Zoom In">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
                </button>
                <button class="control-btn" onclick="zoomGraph(0.6)" title="Zoom Out">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
                </button>
                <button class="control-btn" onclick="fitGraph()" title="Fit View">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>
                </button>
            `;
            container.appendChild(controls);

            // Initialize ForceGraph
            const width = container.clientWidth;
            const height = container.clientHeight || 500;

            // State for interactions
            let highlightNodes = new Set();
            let highlightLinks = new Set();
            let hoverNode = null;
            let selectedNode = null;

            function updateHighlight() {
                if (graphInstance) {
                    // Trigger style updates
                    graphInstance
                        .nodeColor(graphInstance.nodeColor())
                        .linkColor(graphInstance.linkColor())
                        .linkWidth(graphInstance.linkWidth());
                }
            }

            // Colors matching styling logic
            const getNodeColor = (node) => {
                const t = (node.type || "").toLowerCase();
                let color = "#9ca3af";
                if (t.includes("agent") || t.includes("karta")) color = "#ef4444";
                else if (t.includes("object") || t.includes("karma")) color = "#3b82f6";
                else if (t.includes("action") || t.includes("verb") || t.includes("event")) color = "#eab308";
                else if (t.includes("recipient")) color = "#a855f7";
                else if (t.includes("source")) color = "#ec4899";
                else if (t.includes("location") || t.includes("time")) color = "#10b981";

                // Dimming Logic
                if (hoverNode && !highlightNodes.has(node.id)) {
                    return `rgba(80, 80, 80, 0.2)`; // Dimmed
                }
                return color;
            };

            const getLinkColor = (link) => {
                if (hoverNode && !highlightLinks.has(link)) {
                    return 'rgba(50, 50, 50, 0.1)';
                }
                return '#52525b';
            };

            graphInstance = ForceGraph()(container)
                .width(width)
                .height(height)
                .graphData(formattedData)
                .backgroundColor('rgba(0,0,0,0)')
                .nodeId('id')
                .nodeLabel('label')
                .nodeColor(getNodeColor)
                .nodeRelSize(node => node.type === 'event' ? 6 : 4)
                .linkDirectionalArrowLength(3.5)
                .linkDirectionalArrowRelPos(1)
                .linkWidth(link => highlightLinks.has(link) ? 2.5 : 1.5)
                .linkColor(getLinkColor)
                .onNodeHover(node => {
                    // No hover effect if we have a selected node (lock mode)
                    if (selectedNode) return;

                    const elem = document.getElementById('graph-container');
                    elem.style.cursor = node ? 'pointer' : null;

                    hoverNode = node || null;
                    highlightNodes.clear();
                    highlightLinks.clear();

                    if (node) {
                        highlightNodes.add(node.id);
                        // Find neighbors
                        formattedData.links.forEach(link => {
                            if (link.source.id === node.id || link.target.id === node.id) {
                                highlightLinks.add(link);
                                highlightNodes.add(link.source.id);
                                highlightNodes.add(link.target.id);
                            }
                        });
                    }
                    updateHighlight();
                })
                .onNodeClick(node => {
                    // Toggle selection
                    if (selectedNode === node) {
                        selectedNode = null; // Deselect
                        document.getElementById('nodeInspector').classList.remove('visible');
                    } else {
                        selectedNode = node;
                        hoverNode = node; // Lock hover state

                        // Center camera
                        graphInstance.centerAt(node.x, node.y, 1000);
                        graphInstance.zoom(2.5, 1000); // Auto zoom in

                        // Populate Inspector
                        const title = document.getElementById('inspectorTitle');
                        const type = document.getElementById('inspectorType');
                        const content = document.getElementById('inspectorContent');
                        const inspector = document.getElementById('nodeInspector');

                        title.textContent = node.label;
                        type.textContent = node.type || 'Unknown Entity';

                        // Generate property rows
                        let html = '';
                        Object.entries(node).forEach(([k, v]) => {
                            if (['id', 'label', 'type', 'x', 'y', 'vx', 'vy', 'fx', 'fy', 'index', '__bckgDimensions'].includes(k)) return;
                            if (typeof v === 'object') return; // skip complex objects for now
                            html += `<div class="prop-row"><span class="prop-key">${k}</span><span class="prop-val">${v}</span></div>`;
                        });

                        // Fake some data if empty (for demo visuals)
                        if (html === '') {
                            html += `<div class="prop-row"><span class="prop-key">ID</span><span class="prop-val">${node.id}</span></div>`;
                            html += `<div class="prop-row"><span class="prop-key">Connections</span><span class="prop-val">${highlightLinks.size}</span></div>`;
                        }

                        content.innerHTML = html;
                        inspector.classList.add('visible');
                    }
                })
                .onBackgroundClick(() => {
                    selectedNode = null;
                    hoverNode = null;
                    highlightNodes.clear();
                    highlightLinks.clear();
                    document.getElementById('nodeInspector').classList.remove('visible');
                    updateHighlight();
                })
                .nodeCanvasObject((node, ctx, globalScale) => {
                    const label = node.label || node.id;
                    const fontSize = 12 / globalScale;
                    ctx.font = `${fontSize}px Sans-Serif`;

                    // Draw node circle
                    ctx.beginPath();
                    const r = node.type === 'event' ? 6 : 4;
                    ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);
                    ctx.fillStyle = getNodeColor(node);
                    ctx.fill();

                    // Highlight Ring for Selection
                    if (node === selectedNode || node === hoverNode) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.lineWidth = 2 / globalScale;
                        ctx.stroke();

                        // Glow
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.shadowBlur = 15;
                    } else {
                        ctx.shadowBlur = 0;
                    }

                    // Reset stroke for events if not highlighted
                    if (node.type === 'event' && node !== selectedNode && node !== hoverNode) {
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 0.5 / globalScale;
                        ctx.stroke();
                    }

                    // Only draw labels for important nodes or when hovered/selected
                    // to reduce clutter, OR draw all if zoomed in
                    if (globalScale > 1.5 || highlightNodes.has(node.id) || node.type === 'event') {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                        ctx.fillText(label, node.x, node.y + r + 2);
                    }

                    node.__bckgDimensions = [r, r];
                })
                .onNodeDragEnd(node => {
                    node.fx = node.x;
                    node.fy = node.y;
                });

            // Store reference for Neural Link
            currentGraphInstance = graphInstance;

            // Handle resize
            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    const { width, height } = entry.contentRect;
                    if (graphInstance) graphInstance.width(width).height(height);
                }
            });
            resizeObserver.observe(container);
        }

        // Exposed Control Functions
        window.zoomGraph = (factor) => {
            if (graphInstance) {
                const currentZoom = graphInstance.zoom();
                graphInstance.zoom(currentZoom * factor, 400);
            }
        };

        window.fitGraph = () => {
            if (graphInstance) graphInstance.zoomToFit(400, 20);
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENT LISTENERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        processBtn.addEventListener('click', processText);
        loadDemoBtn.addEventListener('click', loadDemo);
        loadStressBtn.addEventListener('click', loadStressTest);
        clearBtn.addEventListener('click', clearAll);
        askBtn.addEventListener('click', askQuestion);

        questionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') askQuestion();
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (graphData.nodes && graphData.nodes.length > 0) {
                renderGraph();
            }
        });

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // NEURAL LINK & AUTO-PILOT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Neural Link: Highlight graph node when hovering text
        window.highlightNodeByLabel = function (label) {
            if (!currentGraphInstance || !label) return;
            const cleanLabel = label.toLowerCase();
            const node = graphData.nodes.find(n =>
                (n.label || '').toLowerCase() === cleanLabel ||
                (n.label || '').toLowerCase().includes(cleanLabel)
            );
            if (node && currentGraphInstance) {
                // Trigger hover effect on the node
                currentGraphInstance.emitParticle(node);
                currentGraphInstance.centerAt(node.x, node.y, 500);
            }
        };

        window.clearNeuralLink = function () {
            // Reset is handled by the graph's own hover logic
        };

        // Auto-Pilot: Focus graph on frame when scrolling
        let autoPilotObserver = null;
        function setupAutoPilotObserver() {
            if (autoPilotObserver) autoPilotObserver.disconnect();
            if (!isStoryMode) return;

            const cards = document.querySelectorAll('.frame-card');
            autoPilotObserver = new IntersectionObserver((entries) => {
                if (!isStoryMode || !currentGraphInstance) return;
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const kriya = entry.target.dataset.kriya;
                        // Find matching event node
                        const eventNode = graphData.nodes.find(n =>
                            n.type === 'event' && (n.label || '').includes(kriya)
                        );
                        if (eventNode) {
                            currentGraphInstance.centerAt(eventNode.x, eventNode.y, 800);
                            currentGraphInstance.zoom(2, 800);
                        }
                        // Highlight active card
                        cards.forEach(c => c.style.borderColor = '');
                        entry.target.style.borderColor = 'var(--color-brand)';
                    }
                });
            }, { root: document.querySelector('.left-column'), threshold: 0.6 });

            cards.forEach(card => autoPilotObserver.observe(card));
        }

        // Toggle for Story Mode (can be called from console or UI)
        window.toggleStoryMode = function () {
            isStoryMode = !isStoryMode;
            console.log('Auto-Pilot:', isStoryMode ? 'ON' : 'OFF');
            if (isStoryMode) setupAutoPilotObserver();
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INIT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        connect();
        renderFramesList();
        renderGraph();
    </script>
</body>

</html>